# JAVA基础—集合

## ArrayList

### 扩容机制

- ArrayList()无参构造函数会使用长度为0的数组
- ArrayList(int initialCapacity)会使用指定容量的数组
- public ArrayList(Collection<? extends E> c)会使用c的大小作为数组容量
- add(Object o)首次扩容为10，再次扩容为上次容量c的1.5倍，即newc=c>>2+c
- addAll(Collection c)没有元素时，扩容为Math.max(10,c的size)，有元素时为Math.max(原容量1.5倍，实际元素个数)

## Fail-Fast

- 一旦发现遍历的同时有其他人来修改，立刻抛出异常，ArrayList的机制
- 原理：记录循环开始前该集合的修改次数expectedModCount，在循环的过程中检查集合的实时修改次数modCount与expectedModCount是否一致，如果不一致，则抛出ConcurrentModificationException

## Fail-Safe

- 发现遍历的同时其他人来修改，应当能有应对策略，例如牺牲一致性来让整个遍历运行完成，CopyOnWriteArrayList的机制
- 原理：读写分离，在遍历时新建了一个对象指向原数组，之后遍历的便是新建的数组，而在添加元素时，是复制了一份原数组，然后将容量设置为原数组加1，元素加在新数组中，最后用新数组替换原数组

## ArrayList vs LinkedList

### ArrayList

- 基于数组，需要连续的内存
- 随机访问快（指根据下标访问）
- 尾部插入、删除性能可以，其他部分插入、删除都会移动数据，因此性能会低
- 可以利用CPU缓存，局部性原理（cpu缓存会将访问的数据的相邻空间的数据一起存入到缓存中）

### LinkedList

- 基于双向链表，无需连续缓存
- 随机访问慢（要沿着链表遍历）
- 头尾插入删除性能高
- 占用内存多（里面存的是Node对象，要存上下指针）

## HashMap

### 底层数据结构1.7与1.8有何不同？

- 1.7 数组+链表
- 1.8 数组+（链表|红黑树）

### 为何要用红黑树，为何不一上来就树化，树化阈值为何是8，何时会树化，何时会退化为链表？

- 扩容：
  - 当当前数据个数>当前容量的0.75时会产生扩容
  - 当某个链表下的数据超过树化阈值8且当前容量小于64时会产生扩容
  - 扩容是容量变为原来的两倍

- 红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应该是偶然情况
  - hash表的查找、更新的时间复杂度为O(1)，而红黑树的为O(log2N)，且TreeNode占用空间也比普通Node的大，如非必要，尽量还是使用链表
  - hash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度是8的链表出现的概率是亿分之6，选择8就是为了让树化几率足够小
- 树化两个条件：链表长度超过树化阈值8且数组容量大于等于64
- 退化：
  - 在扩容时如果拆分树时，树的长度<=6则会退化为链表
  - 在remove结点时，当树的根结点root、root.left、root.right、root.left.left有一个为null时，也会退化

### 索引如何计算？hashcode都有了，为何还要提供hash()方法？数组容量为何是2的n次幂？

- 索引计算：计算对象的hashcode()，再调用HashMap的hash()方法进行二次哈希，最后&(capacity -1)
  - 二次hash的值 % hash当前的容量c
  - 二次hash的值 & (hash当前的容量c - 1) <font color='red'>实际使用</font>
- 二次hash：
  - 计算：hashcode的值 ^ (hashcode>>>16)  （jdk1.8版本）
  - 作用：综合高位数据，让哈希分布更均匀
- 数组容量设置：
  - 计算索引时，如果是2的n次幂可以使用位与运算代替模运算，运算效率更高；扩容时hash & oldGap == 0的元素留在原位置，否则新位置=旧位置+oldGap。oldGap为扩容前的数据容量。 <font color='red'>实际使用</font>。    问题：如果二次hash的值都是偶数，将永远用不到奇数索引，hash分布不那么均匀
  - 使hash分布更均匀的做法：数组容量设置为一个较大的质数

### put方法流程

1. HashMap是懒创建数组的，首次使用才创建数组
2. 计算索引（桶下标）
3. 如果桶下标还没被占用，创建Node占位返回
4. 如果桶下标已经被占用
   - 已经是TreeNode走红黑树的添加或更新逻辑
   - 是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
5. 返回前检查容量是否超过阈值，一旦超过进行扩容
6. 不同：
   - 1.7链表插入是头插法，1.8是尾插法
   - 1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容
   - 1.8在扩容计算Node索引时，会优化。扩容时hash & oldGap == 0的元素留在原位置，否则新位置=旧位置+oldGap。oldGap为扩容前的数据容量

### 加载因子为何默认是0.75f

- 在空间占用与查询时间之间取得较好的权衡
- 大于这个值，空间节省了，但链表就会较长影响性能
- 小于这个值，冲突减少了，但扩容会更频繁，空间占用多

### 多线程下会有什么问题

- 1.7版本的头插法会导致扩容死链（形成a.next=b,b.next=a的局面，导致读取时死循环）
- 数据错乱（1.7,1.8都会），两个线程同时需要占用同一个索引位时，可能会出现两个线程同时读取到该索引位为空，进而插入，导致一个线程的数据被另一个线程的覆盖

### key能否为null，作为key的对象有什么要求

- HashMap的key可以为null，但map的其他实现不一定
- 作为key的对象，必须实现hashcode和equals，并且key的内容不能修改<font color='red'>不可变</font>

### String对象的hashCode如何设计的，为啥每次乘的是31

- 目的是达到较为均匀的散列效果，每个字符串的hashcode足够独特

- 字符串中的每个字符都可以表现为一个数字，称为si，i的范围为0~n-1

- 散列公式为：
  $$
  S_0 * 31^{n-1} + S_1*31^{n-2}+...+S_i*31^{n-1-i}+...+S_{n-1}*31^0
  $$

- 31代入公式有较好的散列特性，并且31*h可以被优化为：

  - 32*h-h
  - 2^5 *h -h
  - h<<5-h

