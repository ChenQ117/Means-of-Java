# JAVA基础—集合

## ArrayList

### 扩容机制

- ArrayList()无参构造函数会使用长度为0的数组
- ArrayList(int initialCapacity)会使用指定容量的数组
- public ArrayList(Collection<? extends E> c)会使用c的大小作为数组容量
- add(Object o)首次扩容为10，再次扩容为上次容量c的1.5倍，即newc=c>>1+c
- addAll(Collection c)没有元素时，扩容为Math.max(10,c的size)，有元素时为Math.max(原容量1.5倍，实际元素个数)

## Fail-Fast

- 一旦发现遍历的同时有其他人来修改，立刻抛出异常，ArrayList的机制
- 原理：记录循环开始前该集合的修改次数expectedModCount，在循环的过程中检查集合的实时修改次数modCount与expectedModCount是否一致，如果不一致，则抛出ConcurrentModificationException

## Fail-Safe

- 发现遍历的同时其他人来修改，应当能有应对策略，例如牺牲一致性来让整个遍历运行完成，CopyOnWriteArrayList的机制
- 原理：读写分离，在遍历时新建了一个对象指向原数组，之后遍历的便是新建的数组，而在添加元素时，是复制了一份原数组，然后将容量设置为原数组加1，元素加在新数组中，最后用新数组替换原数组

## ArrayList vs LinkedList

### ArrayList

- 基于数组，需要连续的内存
- 随机访问快（指根据下标访问）
- 尾部插入、删除性能可以，其他部分插入、删除都会移动数据，因此性能会低
- 可以利用CPU缓存，局部性原理（cpu缓存会将访问的数据的相邻空间的数据一起存入到缓存中）

### LinkedList

- 基于双向链表，无需连续缓存
- 随机访问慢（要沿着链表遍历）
- 头尾插入删除性能高
- 占用内存多（里面存的是Node对象，要存上下指针）

## HashMap

### 底层数据结构1.7与1.8有何不同？

- 1.7 数组+链表
- 1.8 数组+（链表|红黑树）

### 为何要用红黑树，为何不一上来就树化，树化阈值为何是8，何时会树化，何时会退化为链表？

- 扩容：
  - 当当前数据个数>当前容量的0.75时会产生扩容
  - 当某个链表下的数据超过树化阈值8且当前容量小于64时会产生扩容
  - 扩容是容量变为原来的两倍

- 红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应该是偶然情况
  - hash表的查找、更新的时间复杂度为O(1)，而红黑树的为O(log2N)，且TreeNode占用空间也比普通Node的大，如非必要，尽量还是使用链表
  - hash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度是8的链表出现的概率是亿分之6，选择8就是为了让树化几率足够小
- 树化两个条件：链表长度超过树化阈值8且数组容量大于等于64
- 退化：
  - 在扩容时如果拆分树时，树的长度<=6则会退化为链表
  - 在remove结点时，当树的根结点root、root.left、root.right、root.left.left有一个为null时，也会退化

### 索引如何计算？hashcode都有了，为何还要提供hash()方法？数组容量为何是2的n次幂？

- 索引计算：计算对象的hashcode()，再调用HashMap的hash()方法进行二次哈希，最后&(capacity -1)
  - 二次hash的值 % hash当前的容量c
  - 二次hash的值 & (hash当前的容量c - 1) <font color='red'>实际使用</font>
- 二次hash：
  - 计算：hashcode的值 ^ (hashcode>>>16)  （jdk1.8版本）
  - 作用：综合高位数据，让哈希分布更均匀
- 数组容量设置：
  - 计算索引时，如果是2的n次幂可以使用位与运算代替模运算，运算效率更高；扩容时hash & oldGap == 0的元素留在原位置，否则新位置=旧位置+oldGap。oldGap为扩容前的数据容量。 <font color='red'>实际使用</font>。    问题：如果二次hash的值都是偶数，将永远用不到奇数索引，hash分布不那么均匀
  - 使hash分布更均匀的做法：数组容量设置为一个较大的质数

### put方法流程

1. HashMap是懒创建数组的，首次使用才创建数组
2. 计算索引（桶下标）
3. 如果桶下标还没被占用，创建Node占位返回
4. 如果桶下标已经被占用
   - 已经是TreeNode走红黑树的添加或更新逻辑
   - 是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
5. 返回前检查容量是否超过阈值，一旦超过进行扩容
6. 不同：
   - 1.7链表插入是头插法，1.8是尾插法
   - 1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容
   - 1.8在扩容计算Node索引时，会优化。扩容时hash & oldGap == 0的元素留在原位置，否则新位置=旧位置+oldGap。oldGap为扩容前的数据容量

### 加载因子为何默认是0.75f

- 在空间占用与查询时间之间取得较好的权衡
- 大于这个值，空间节省了，但链表就会较长影响性能
- 小于这个值，冲突减少了，但扩容会更频繁，空间占用多

### 多线程下会有什么问题

- 1.7版本的头插法会导致扩容死链（形成a.next=b,b.next=a的局面，导致读取时死循环）
- 数据错乱（1.7,1.8都会），两个线程同时需要占用同一个索引位时，可能会出现两个线程同时读取到该索引位为空，进而插入，导致一个线程的数据被另一个线程的覆盖

### key能否为null，作为key的对象有什么要求

- HashMap的key可以为null，但map的其他实现不一定
- 作为key的对象，必须实现hashcode和equals，并且key的内容不能修改<font color='red'>不可变</font>

### String对象的hashCode如何设计的，为啥每次乘的是31

- 目的是达到较为均匀的散列效果，每个字符串的hashcode足够独特

- 字符串中的每个字符都可以表现为一个数字，称为si，i的范围为0~n-1

- 散列公式为：
  $$
  S_0 * 31^{n-1} + S_1*31^{n-2}+...+S_i*31^{n-1-i}+...+S_{n-1}*31^0
  $$

- 31代入公式有较好的散列特性，并且31*h可以被优化为：

  - 32*h-h
  - 2^5 *h -h
  - h<<5-h

## Hashtable vs ConcurrentHashMap

- Hashtable和ConcurrentHashMap都是线程安全的Map集合，且key都不能为null
- Hashtable并发度低，整个Hashtable对应一把锁，同一时刻，只能有一个线程操作它
- 1.8之前ConcurrentHashMap使用Segment+数组+链表的结构，每个Segment对应一把锁，如果多个线程访问不同的Segment，则不会冲突
- 1.8开始ConcurrentHashMap将数组的每个头结点作为锁，如果多个线程访问的头结点不同，则不会冲突

## Hashtable

### 扩容

- 初始容量为11
- 每次扩容为上一次的容量*2+1
- 大于容量的0.75时触发扩容

### 索引计算

- 不需要二次哈希（因为容量基本上为质数），直接用（hashcode&07xFFFFFFF）%容量，保证结果为正数

## 1.7 版本的ConcurrentHashMap

- 饿汉式初始化
- segment数组+HashEntry数组+链表
- 头插法
- 超过0.75才扩容
- 每个Segment对应一把锁

### 并发度

- 构造函数传入容量、扩容因子、并发度clevel参数
- 小数组的初始容量为容量/并发度，最小为2
- segment不能扩容，用并发度指定的

### 索引计算

- Segment索引：取二次hash值的高n位二进制作为索引值（当并发度为16时，取高4位，当并发度为32时，取高5位）,n满足并发度=2^n。      代码公式：（二次hash值>>>segmentShift）&segmentMask
- 小数组索引：取二次hash值的低n位，其中n满足小数组的容量=2^n

### 扩容

- Segment不能扩容
- 当当前Segment下的数据超出当前小数组容量的0.75时触发扩容，扩为原来的两倍
- 使用头插法，但因为每个Segment对应一把锁，所以不会造成扩容死链
- 扩容是每个segment各扩各的，互不相干

### Segment[0]原型

- 初始化时segment[0]下会根据容量和并发度创建小数组，其他segment下没有小数组
- 当其他segment需要创建小数组时，会参照segment[0]的小数组个数去创建
- 当segment[0]下的小数组个数更改了，其他未创建小数组的segment也会根据更改后的segment[0]的小数组个数去创建

## 1.8版本的ConcurrentHashMap

- 懒汉式初始化，当put时才会创建数据结构
- 数组+链表|红黑树
- 尾插法
- 达到0.75就扩容
- 每个链表头对应一把锁

### capacity和factor

- capacity代表需要放入的容量，实际开辟的容量为一个比capacity除以0.75大的2的幂次方， 即实际容量c满足c=2^n && 0.75c>capacity，比如capacity=11时，c=16；capacity=12时，c=32
- factor扩容因子：只在构造函数初始化时起作用，之后不管factor是多少，都是按照达到c的0.75就扩容

### 并发put

- 每个链表头对应一把锁
- 当两个线程同时向一个表头插入数据时，会互斥，先抢到锁的先插入数据
- 当两个线程同时向不同表头插入数组时，可以并发执行

### 扩容

- 数组迁移：从后向前迁移，先从15号数组开始往前处理，处理完的链表会添加一个forwardingNode，表示已经迁移了
- 扩容时get：当迁移一半时，进行get操作，此时会根据索引判断是在旧的数组中查找还是在新的数组中查找，
  - 对于只有一个结点或者没有结点的链表：当发现旧的数组中对应索引下的链表有forwardingNode则到新的数组中去查找。不会阻塞，可以并发运行
  - 对于有多个结点的链表：当该结点的next会改变时，此时会复制原结点，将复制的结点添加到扩容后的数组中，get的是扩容前的数组中的结点；当该结点的next不会改变时，此时直接加到扩容后的数组中

- 扩容时put：
  - 当put的数据需要插入到处于当前正在迁移的链表的前半部分，则并发put，不需要加锁
  - 当put的数据需要插入到正在迁移的链表，此时会阻塞，链表头被锁住
  - 当put的数据需要插入到具有forwardingNode的链表中，不会等待，因为扩容线程一次性只能处理16个链表，会有多个扩容线程，所以新来的这个put线程会帮忙处理扩容

## ThreadLocalMap

- 初始容量：16
- 扩容因子：2/3

- 哈希冲突：

  开放寻址法：如果冲突，找索引的下一个空闲的位置存放该数据

- ThreadLocalMap中的key（即ThreadLocal）为什么要设计为弱引用

  - Thread可能需要长期运行（如线程池中的线程），如果key不再使用，需要在内存不足（GC）时释放占用的内存
  - 但GC仅是让key的内存释放，后续还要根据key是否为null来进一步释放值的内存
    - 获取key，发现key为null时释放值
    - set key时，会启用启发式扫描，清除临近的null key，启发次数与元素个数，是否发现null key有关
    - remove时（推荐），因为一般使用ThreadLocal时都把它作为静态变量，因此无法GC，此时可以手动释放

